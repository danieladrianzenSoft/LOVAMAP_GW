import axios, { AxiosError, AxiosResponse } from "axios";
import History from "../helpers/History";
import { store } from "../stores/store";
import { User, UserLogin, UserRegister } from "../models/user";
import { ApiResponse } from "../models/apiResponse";
import { Tag } from "../models/tag";
import { ScaffoldGroup, ScaffoldGroupToCreate } from "../models/scaffoldGroup";
import { DescriptorType } from "../models/descriptorType";
import { Image, ImageToCreate, ImageToUpdate } from "../models/image";
import environment from "../environments/environment"
import { Domain } from "../models/domain";

axios.defaults.baseURL = environment.baseUrl;

axios.interceptors.request.use(async (config) => {
    const token = store.commonStore.getAccessToken;
	// const isLoggedIn = store.commonStore.isLoggedIn;

    config.headers.Authorization = `Bearer ${token || ''}`;
    return config;
});

axios.interceptors.response.use(response => {
    return response;
}, (error: AxiosError) => {
    if (!error.response) {
        console.error('AxiosError without response:', error);
        return Promise.reject(error);
    }
    
    const {status, data} = error.response;

    switch (status) {
        case 400:
            console.error('Bad request:', data);
            break;
        case 401:
            store.userStore.logout();
            if (window.location.pathname.startsWith("/login")) {
                break;
            }
            const currentPath = window.location.pathname + window.location.search;
            History.push(`/login?redirect=${encodeURIComponent(currentPath)}`);
            break;
        case 404:
            console.error('Not found:', data);
            break;
        case 500:
            console.error('Server error:', data);
            break;
    }
    return Promise.reject(data);
});

const responseBody = <T> (response: AxiosResponse<T>) => response.data;

const requests = {
	get: <T> (url: string) => axios.get<T>(url).then(responseBody),
	post: <T> (url: string, body: {}) => axios.post<T>(url, body).then(responseBody),
	put: <T> (url: string, body: {}) => axios.put<T>(url, body).then(responseBody),
	del: <T> (url: string) => axios.delete<T>(url).then(responseBody),
}

const Resources = {
	getAutogeneratedTags: () => requests.get<ApiResponse<Tag[]>>('/resources/tags'),
    getDescriptorTypes: () => requests.get<ApiResponse<DescriptorType[]>>('/resources/descriptorTypes')
}

const Users = {
	getCurrent: () => requests.get<ApiResponse<User>>('/users/getCurrentUser'),
	login: (user: UserLogin) => requests.post<ApiResponse<User>>('/auth/login', user),
	register: (user: UserRegister) => requests.post<ApiResponse<User>>('/auth/register', user),
}

const ScaffoldGroups = {
	getSummarized: (queryParams: string) => requests.get<ApiResponse<ScaffoldGroup[]>>('/scaffoldGroups' + queryParams),
	getPublic: (queryParams: string) => requests.get<ApiResponse<ScaffoldGroup[]>>('/scaffoldGroups/public' + queryParams),
    getSummary: (id: number) => requests.get<ApiResponse<ScaffoldGroup>>('/scaffoldGroups/' + id + '/summary'),
	getDetailed: (id: number) => requests.get<ApiResponse<ScaffoldGroup>>('/scaffoldGroups/' + id),
    getDetailedForExperiment: (queryParams: string) => requests.get<ApiResponse<ScaffoldGroup[]>>('/scaffoldGroups/detailed' + queryParams),
    uploadScaffoldGroup: (scaffoldGroup: ScaffoldGroupToCreate) => requests.post<ApiResponse<ScaffoldGroup>>('/scaffoldGroups/create', scaffoldGroup),
    uploadScaffoldGroupBatch: (scaffoldGroups: ScaffoldGroupToCreate[]) => requests.post<ApiResponse<ScaffoldGroup[]>>('/scaffoldGroups/createBatch', scaffoldGroups),
    // uploadScaffoldGroupImage: (image: ImageToCreate) => requests.post<ApiResponse<Image>>('/scaffoldGroups/image', image),
    getUploadedScaffoldGroups: () => requests.get<ApiResponse<ScaffoldGroup[]>>('/users/me/scaffoldgroups'),
    uploadScaffoldGroupImage: async (scaffoldGroupId: number, image: ImageToCreate, imageType?: string) => {
        const formData = new FormData();
        formData.append('file', image.file); // Append the image file
        formData.append('scaffoldGroupId', image.scaffoldGroupId.toString());
        if (image.scaffoldId) formData.append('scaffoldId', image.scaffoldId.toString());
        if (imageType) formData.append('imageType', imageType); // Optional image type

        const response =  await axios.post<ApiResponse<Image>>(`/scaffoldGroups/${scaffoldGroupId}/image`, formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });

        return response.data;
    },
    updateImage: (scaffoldGroupId: number, image: ImageToUpdate) => requests.put<ApiResponse<ScaffoldGroup>>(`/scaffoldGroups/${scaffoldGroupId}/image/${image.id}`, image),
    deleteImage: (scaffoldGroupId: number, imageId: number) => requests.del<ApiResponse<ScaffoldGroup>>(`/scaffoldGroups/${scaffoldGroupId}/image/${imageId}`),
}

const Domains = {
    visualize: async (scaffoldId: number) => {
        const response = await axios.get(`/domains/${scaffoldId}`, {
            responseType: 'blob', // Ensures we get the response as binary data
            headers: {
                'Accept': 'application/json, text/plain, */*'
            }
        });

        // Extract metadata from headers
        const domain: Domain = {
            id: parseInt(response.headers['x-domain-id'], 10) || undefined,
            scaffoldId: parseInt(response.headers['x-scaffold-id'], 10) || undefined,
            category: response.headers['x-category'] || undefined,
            voxelCount: parseInt(response.headers['x-voxel-count'], 10) || undefined,
            voxelSize: parseInt(response.headers['x-voxel-size'], 10) || undefined,
            domainSize: response.headers['x-domain-size'] || undefined,
            meshFilePath: response.headers['x-mesh-filepath'] || undefined
        };

        return { file: response.data, domain };
    },
    createDomain: async (formData: FormData) => {
        const response = await axios.post<ApiResponse<Domain>>(`/domains/create`, formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });

        return response.data;
    },
}

const agent = {
	Resources,
	Users,
	ScaffoldGroups,
    Domains
}

export default agent;