import axios, { AxiosError, AxiosProgressEvent, AxiosResponse } from "axios";
import History from "../helpers/History";
import { store } from "../stores/store";
import { User, UserChangePassword, UserConfirmEmail, UserLogin, UserRegister, UserResetPassword } from "../models/user";
import { ApiResponse } from "../models/apiResponse";
import { Tag } from "../models/tag";
import { ScaffoldGroup, ScaffoldGroupMatch, ScaffoldGroupToCreate } from "../models/scaffoldGroup";
import { DescriptorType } from "../models/descriptorType";
import { Image, ImageCategory, ImageToCreate, ImageToUpdate } from "../models/image";
import environment from "../environments/environment"
import { Domain } from "../models/domain";
import { Job } from "../models/job";
import { ScaffoldWithMissingThumbnail } from "../models/scaffold";
import { PoreInfo, PoreInfoForScaffoldGroup } from "../models/poreInfo";
import { DomainMetadata } from "../models/domainMetadata";
import { AiScaffoldGroupSearch } from "../models/aiScaffoldGroupSearch";
import { BatchOperationResult } from "../models/batchOperationResult";
import { ScaffoldGroupData } from "../models/scaffoldGroupData";
import { DescriptorSeedResult } from "../models/descriptor";
import { Publication } from "../models/publication";
import { InputGroup } from "../models/inputGroup";

axios.defaults.baseURL = environment.baseUrl;

axios.interceptors.request.use(async (config) => {
    const token = store.commonStore.getAccessToken;
    config.headers.Authorization = `Bearer ${token || ''}`;
    return config;
});

axios.interceptors.response.use(response => {
    return response;
}, (error: AxiosError) => {
    if (!error.response) {
        console.error('AxiosError without response:', error);
        return Promise.reject(error);
    }
    
    const {status, data} = error.response;
    const responseData = data as ApiResponse<any>;

    switch (status) {
        case 401:
            store.userStore.logout();
            if (window.location.pathname.startsWith("/login")) {
                break;
            }
            const currentPath = window.location.pathname + window.location.search;
            History.push(`/login?redirect=${encodeURIComponent(currentPath)}`);
            break;
    }
    return Promise.reject(responseData);
});

const responseBody = <T> (response: AxiosResponse<T>) => response.data;

const requests = {
	get: <T> (url: string) => axios.get<T>(url).then(responseBody),
	post: <T> (url: string, body: {}) => axios.post<T>(url, body).then(responseBody),
	put: <T> (url: string, body: {}) => axios.put<T>(url, body).then(responseBody),
	del: <T> (url: string) => axios.delete<T>(url).then(responseBody),
    postForm: <T>(
        url: string,
        form: FormData,
        onUploadProgress?: (e: AxiosProgressEvent) => void
    ) =>
        axios
        .post<T>(url, form, {
            headers: { "Content-Type": "multipart/form-data" },
            onUploadProgress,
        })
        .then(responseBody),
}

const Resources = {
	getAutogeneratedTags: () => requests.get<ApiResponse<Tag[]>>('/resources/tags'),
    getDescriptorTypes: () => requests.get<ApiResponse<DescriptorType[]>>('/resources/descriptorTypes')
}

const Seed = {
    getEligibleScaffoldIdsForDescriptorSeeding: (descriptorName: string) => requests.get<ApiResponse<number[]>>('/seed/descriptors?name=' + descriptorName),
    seedDescriptors: (body: any) => requests.post<ApiResponse<DescriptorSeedResult>>('/seed/descriptors', body)
}

const Users = {
	getCurrent: () => requests.get<ApiResponse<User>>('/users/getCurrentUser'),
	login: (user: UserLogin) => requests.post<ApiResponse<User>>('/auth/login', user),
	register: (user: UserRegister) => requests.post<ApiResponse<User>>('/auth/register', user),
    confirmEmail: (userConfirmEmail: UserConfirmEmail) => requests.post<ApiResponse<string>>('/auth/confirm-email', userConfirmEmail),
    confirmEmailRequest: (email: string) => requests.post<ApiResponse<string>>('/auth/confirm-email-request', {email: email}),
    forgotPassword: (email: string) => requests.post<ApiResponse<string>>('/auth/forgot-password', {email: email}),
    resetPassword: (userResetPassword: UserResetPassword) => requests.post<ApiResponse<string>>('/auth/reset-password', userResetPassword),
    changePassword: (userChangePassword: UserChangePassword) => requests.post<ApiResponse<string>>('/auth/change-password', userChangePassword),
}

const ScaffoldGroups = {
    getAllIds: () => requests.get<ApiResponse<number[]>>('/scaffoldgroups/ids'),
	getSummarized: (queryParams: string) => requests.get<ApiResponse<ScaffoldGroup[]>>('/scaffoldgroups' + queryParams),
	getPublic: (queryParams: string) => requests.get<ApiResponse<ScaffoldGroup[]>>('/scaffoldgroups/public' + queryParams),
    getSummary: (id: number) => requests.get<ApiResponse<ScaffoldGroup>>('/scaffoldgroups/' + id + '/summary'),
    search: (prompt: string) => requests.post<ApiResponse<AiScaffoldGroupSearch>>('/scaffoldgroups/search', {"prompt": prompt}),
    getGroupSummaryByScaffoldId: (id: number) => requests.get<ApiResponse<ScaffoldGroup>>('/scaffoldgroups/scaffold/' + id + '/summary'),
	getDetailed: (id: number) => requests.get<ApiResponse<ScaffoldGroup>>('/scaffoldGroups/' + id),
    getDetailedForExperiment: (queryParams: string) => requests.get<ApiResponse<ScaffoldGroup[]>>('/scaffoldgroups/detailed' + queryParams),
    getDataForVisualization: (scaffoldGroupId: number, queryParams: string) => requests.get<ApiResponse<ScaffoldGroupData>>(`/scaffoldgroups/data/${scaffoldGroupId}` + queryParams),
    getDataForVisualizationRandom: (queryParams: string) => requests.get<ApiResponse<ScaffoldGroupData>>(`/scaffoldgroups/data/random/` + queryParams),
    getScaffoldGroupMatches: (inputGroupForMatch: InputGroup) => requests.post<ApiResponse<ScaffoldGroupMatch[]>>(`/scaffoldgroups/matches`, inputGroupForMatch),
    uploadScaffoldGroup: (scaffoldGroup: ScaffoldGroupToCreate) => requests.post<ApiResponse<ScaffoldGroup>>('/scaffoldgroups/create', scaffoldGroup),
    uploadScaffoldGroupBatch: (scaffoldGroups: ScaffoldGroupToCreate[]) => requests.post<ApiResponse<ScaffoldGroup[]>>('/scaffoldgroups/createBatch', scaffoldGroups),
    uploadScaffoldGroupBatchStreamed: (
        scaffoldGroups: any[],
        onProgressPct?: (pct: number) => void
    ) => {
        const blob = new Blob([JSON.stringify(scaffoldGroups)], {
        type: "application/json",
        });
        const form = new FormData();
        form.append("batch", blob, "scaffold-batch.json");

        return requests.postForm<ApiResponse<ScaffoldGroup[]>>("/scaffoldgroups/createBatchUpload",form,
            (evt) => {
                const total = evt.total ?? 0;
                if (onProgressPct && total > 0) {
                    onProgressPct(Math.round((evt.loaded / total) * 100));
                } else if (onProgressPct && typeof evt.progress === "number") {
                    onProgressPct(Math.round(evt.progress * 100));
                }
            }
        );
    },
    resetNameAndComments: (scaffoldGroupIds: {scaffoldGroupIds: number[]}) => requests.post<ApiResponse<BatchOperationResult>>('scaffoldGroups/reset-names', scaffoldGroupIds),
    getUploadedScaffoldGroups: () => requests.get<ApiResponse<ScaffoldGroup[]>>('/users/me/scaffoldgroups'),
    delete: (id: number) => requests.del<ApiResponse<string>>('scaffoldgroups/' + id),
    uploadScaffoldGroupImage: async (scaffoldGroupId: number, image: ImageToCreate) => {
        const formData = new FormData();
        formData.append('file', image.file); // Append the image file
        formData.append('scaffoldGroupId', image.scaffoldGroupId.toString());
        if (image.scaffoldId) formData.append('scaffoldId', image.scaffoldId.toString());
        if (image.category !== null && image.category !== undefined) {
            formData.append('category', ImageCategory[image.category]);
          }

        const response =  await axios.post<ApiResponse<Image>>(`/scaffoldgroups/${scaffoldGroupId}/images`, formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });

        return response.data;
    },
    getImageIdsForDeletion: (queryParams: string) => requests.get<ApiResponse<number[]>>('/scaffoldgroups/images/ids-for-deletion' + queryParams),
    updateImage: (scaffoldGroupId: number, image: ImageToUpdate) => requests.put<ApiResponse<ScaffoldGroup>>(`/scaffoldgroups/${scaffoldGroupId}/images/${image.id}`, image),
    deleteImage: (scaffoldGroupId: number, imageId: number) => requests.del<ApiResponse<ScaffoldGroup>>(`/scaffoldgroups/${scaffoldGroupId}/images/${imageId}`),
    deleteImages: (imageIds: {imageIds: number[]}) => requests.post<ApiResponse<BatchOperationResult>>('/scaffoldgroups/images/batch-delete', imageIds),
    getScaffoldsWithMissingThumbnails: () => requests.get<ApiResponse<ScaffoldWithMissingThumbnail[]>>(`/scaffoldgroups/images/missing-thumbnails`)
}

const Descriptors = {
    getAllDescriptorTypes: () => requests.get<ApiResponse<DescriptorType[]>>('/descriptors'),
    getPoreInfo: (scaffoldGroupId: number) => requests.get<ApiResponse<PoreInfo>>(`/descriptors/${scaffoldGroupId}`),
    getPoreInfoForScaffoldGroup: (scaffoldGroupId: number, queryParams: string) => requests.get<ApiResponse<PoreInfoForScaffoldGroup>>(`/descriptors/data/${scaffoldGroupId}`+ queryParams),
    getPoreInfoForRandomScaffoldGroup: (queryParams: string) => requests.get<ApiResponse<PoreInfoForScaffoldGroup>>(`/descriptors/data/random/`+ queryParams),

}

const Domains = {
    visualize: async (scaffoldId?: number | null, category?: number | null) => {
        const id = scaffoldId ?? -1
        const response = await axios.get(`/domains/${id}`, {
            params: {
                category: category ?? 0  // Default to 0 (Particles) if not provided
            },
            responseType: 'blob', // Ensures we get the response as binary data
            headers: {
                'Accept': 'application/json, text/plain, */*'
            }
        });

        // Extract metadata from headers
        const domain: Domain = {
            id: parseInt(response.headers['x-domain-id'], 10) || undefined,
            scaffoldId: parseInt(response.headers['x-scaffold-id'], 10) || undefined,
            category: response.headers['x-category'] || undefined,
            voxelCount: parseInt(response.headers['x-voxel-count'], 10) || undefined,
            voxelSize: parseInt(response.headers['x-voxel-size'], 10) || undefined,
            domainSize: response.headers['x-domain-size'] || undefined,
            originalFileName: response.headers['x-original-filename'] || undefined,
        };

        return { file: response.data, domain };
    },
    
    getDomainMetadata: (domainId: number) => requests.get<ApiResponse<DomainMetadata | null>>('/domains/' + domainId.toString() + '/metadata'),

    createDomain: async (formData: FormData) => {
        const response = await axios.post<ApiResponse<Domain>>(`/domains/create`, formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });

        return response.data;
    },
}

const Jobs = {
    submitJob: async (job: Job, dx: number) => {
        const formData = new FormData();
        if (job.csvFile) {
            formData.append('csvFile', job.csvFile);
        }
        else if (job.datFile) {
            formData.append('datFile', job.datFile);
        }
        else if (job.jsonFile) {
            formData.append('jsonFile', job.jsonFile);
        }
        formData.append('dx', dx.toString());

        const response =  await axios.post<ApiResponse<Job>>(`/jobs/submit-job`, formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });

        return response.data;
    },
}

const Publications = {
    getById: async (publicationId: number) => requests.get<ApiResponse<Publication>>(`/publications/${publicationId}`),
    getAll: async () => requests.get<ApiResponse<Publication[]>>(`/publications`),
}

const agent = {
	Resources,
    Seed,
	Users,
	ScaffoldGroups,
    Descriptors,
    Domains,
    Jobs,
    Publications
}

export default agent;