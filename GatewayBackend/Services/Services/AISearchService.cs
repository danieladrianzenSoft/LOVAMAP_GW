
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Data;
using Data.Models;
using Infrastructure.DTOs;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Repositories.IRepositories;
using Repositories.Repositories;
using Services.IServices;

namespace Services.Services
{
	public class AISearchService : IAISearchService
	{
		private readonly DataContext _context;
		private readonly HttpClient _httpClient;
		private readonly IConfiguration _configuration;
		private readonly ITagService _tagService;
		private readonly IScaffoldGroupService _scaffoldGroupService;
		private readonly IAISearchRepository _aiSearchRepository;
		private readonly ILogger<AISearchService> _logger;

		public AISearchService(DataContext context,
			IConfiguration configuration,
			IScaffoldGroupService scaffoldGroupService,
			ITagService tagService,
			IAISearchRepository aiSearchRepository,
			ILogger<AISearchService> logger)
		{
			_context = context;
			_configuration = configuration;
			_tagService = tagService;
			_scaffoldGroupService = scaffoldGroupService;
			_aiSearchRepository = aiSearchRepository;
			_logger = logger;
			_httpClient = new HttpClient
			{
				BaseAddress = new Uri("https://api.openai.com/v1/")
			};

			var apiKey = _configuration["OpenAIApiKey"];

			_httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {apiKey}");
		}

		public async Task<(bool Succeeded, string ErrorMessage, AIScaffoldSearchResponse? searchResponse)> RunSearchScaffoldGroupPipeline(string searchPrompt, string userId)
		{
			try
			{
				var (succeededSearch, errorMessageSearch, scaffoldFilter) = await SearchScaffoldGroup(searchPrompt);

				if (!succeededSearch || scaffoldFilter == null)
				{
					return (false, errorMessageSearch, null);
				}

				var (succeeded, errorMessage, scaffoldGroups) = await _scaffoldGroupService.GetFilteredScaffoldGroups(scaffoldFilter, userId);

				if (!succeeded)
				{
					return (false, errorMessage, null);
				}

				var summarizedGroups = scaffoldGroups?.OfType<ScaffoldGroupSummaryDto>();

				var selectedTags = await _tagService.GetTagsByIds(scaffoldFilter.TagIds ?? new List<int>());

				var responsePayload = new AIScaffoldSearchResponse
				{
					ScaffoldGroups = summarizedGroups ?? Enumerable.Empty<ScaffoldGroupSummaryDto>(),
					SelectedTags = selectedTags.Select(t => new TagForFilterDto
					{
						Id = t.Id,
						Name = t.Name,
						ReferenceProperty = t.ReferenceProperty
					}).ToList(),
					SelectedParticleSizes = scaffoldFilter.ParticleSizes?.ToList() ?? new List<int>()
				};

				return (true, "", responsePayload);

			}
			catch (Exception ex)
			{

				_logger.LogError(ex, "AISearchService.SearchScaffoldGroup failed.");
				return (false, ex.Message, null);
			}



		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldFilter? scaffoldFilter)> SearchScaffoldGroup(string searchPrompt)
		{
			try
			{
				// Step 1: Get valid tag names
				var validTags = await _tagService.GetAutogeneratedTags();
				var validTagNames = validTags.Select(t => t.Name);
				var tagListStr = string.Join(", ", validTagNames.Select(t => $"\"{t}\""));

				// Step 2: Construct the prompt
				string prompt = @$"
					You are an assistant for a materials science platform, where users can filter and search for a specific type
					of granular material 'scaffold group'.

					Your job is to convert the text input into the following C# object structure, in JSON format:

					ScaffoldFilter {{
						ICollection<int>? ParticleSizes,
						ICollection<string>? TagNames
					}}

					Instructions:
					- Use only the following valid tag names (case-insensitive): [{tagListStr}]
					- There should be no text or characters before or after the object, as I will be parsing it as is. 
					- You are allowed to **interpret synonyms or related words** in the user input. For example, if a user says 'cylindrical', you may map that to 'rods' if 'rods' is in the valid tag list.
					- If a word in the user's input clearly corresponds to one of the valid tags in meaning (even if not exact wording), use it.
					- If no valid tags are mentioned or matched, set TagNames to null.
					- If particle sizes are mentioned (e.g., '200 microns', '300 um', etc.), assume what is provided is the particle diameter and extract those integers into ParticleSizes.
					- If particle sizes are given with specific reference to it being the radius, multiply the provided value by 2 to get the diameter and add that into ParticleSizes. 
					- If the user provides a volume (e.g., 'volume of 5000 µm³'), convert it into diameter using the formula d = 2 * ((3 * V) / (4π))^(1/3), round the computed diameter to the nearest integer, and include it in ParticleSizes.
					- If no reference to size is provided, set ParticleSizes to null.
					- If particle sizes are mentioned but in the context of volume (e.g., '500um3', specific mention of volume), calculate the diameter assuming a spherical particle and add that integer into ParticleSizes.
					- Return only the JSON object. Do not include comments or explanations.

					If the user's input mentions a known tag, include it in TagNames. If not, set TagNames to null. 
					If they mention particle sizes (e.g., 200 microns, 400 um, etc.), include those as integers in ParticleSizes.

					User's search prompt input:
					{searchPrompt}
				";

				var model = "gpt-4o-mini";

				// Step 3: Create AISearch entry
				var aiSearch = new AISearch
				{
					Category = AISearchCategory.ScaffoldGroup,
					SearchText = searchPrompt,
					Prompt = prompt,
					Model = model
				};


				// Step 4: Prepare and send OpenAI request
				var requestBody = new
				{
					model = model,
					messages = new[]
					{
						new { role = "user", content = prompt }
					},
					max_tokens = 500
					// temperature = 0.2
				};

				var jsonContent = new StringContent(
					JsonSerializer.Serialize(requestBody),
					Encoding.UTF8,
					"application/json");

				var response = await _httpClient.PostAsync("chat/completions", jsonContent);
				if (!response.IsSuccessStatusCode)
				{
					var errorText = await response.Content.ReadAsStringAsync();
					return (false, $"OpenAI API error: {errorText}", null);
				}

				var responseJson = await response.Content.ReadAsStringAsync();
				using var doc = JsonDocument.Parse(responseJson);
				var message = doc.RootElement
								.GetProperty("choices")[0]
								.GetProperty("message")
								.GetProperty("content")
								.GetString();

				// Step 5: Deserialize into ScaffoldFilter
				ScaffoldFilter? filter;
				try
				{
					filter = JsonSerializer.Deserialize<ScaffoldFilter>(message!, new JsonSerializerOptions
					{
						PropertyNameCaseInsensitive = true
					});
				}
				catch (Exception ex)
				{
					_logger.LogError(ex, "Failed to deserialize AI response into ScaffoldFilter");
					return (false, "Could not interpret AI response as a valid filter.", null);
				}

				aiSearch.AIModelOutput = message;
				aiSearch.Result = JsonSerializer.Serialize(filter, new JsonSerializerOptions
				{
					WriteIndented = false,
					PropertyNamingPolicy = JsonNamingPolicy.CamelCase
				});
				aiSearch.ResultAt = DateTime.UtcNow;

				_aiSearchRepository.Add(aiSearch);
				await _context.SaveChangesAsync();

				return (true, "", filter);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "AISearchService.SearchScaffoldGroup failed.");
				return (false, "An error occurred while processing your AI search request.", null);
			}
		}
	}
}