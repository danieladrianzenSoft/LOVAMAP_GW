
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data;
using Data.Models;
using Repositories.IRepositories;
using Infrastructure.DTOs;
using Infrastructure.IHelpers;
using Services.IServices;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using CloudinaryDotNet;

namespace Services.Services
{	public class ScaffoldGroupService : IScaffoldGroupService
	{
		private readonly DataContext _context;
		private readonly IModelMapper _modelMapper;
		private readonly IUserAuthHelper _userAuthHelper;
		private readonly IScaffoldGroupMetadataService _metadataService;
		private readonly IScaffoldGroupRepository _scaffoldGroupRepository;
		private readonly IDescriptorService _descriptorService;
		private readonly IDownloadService _downloadService;
		private readonly IDomainService _domainService;
		private readonly ITagService _tagService;
		private readonly IImageService _imageService;
		private readonly ILogger<ScaffoldGroupService> _logger;

		public ScaffoldGroupService(DataContext context, IModelMapper modelMapper, 
			IScaffoldGroupMetadataService metadataService, IScaffoldGroupRepository scaffoldGroupRepository, 
			IDescriptorService descriptorService, IDownloadService downloadService, ITagService tagService, 
			IUserAuthHelper userAuthHelper, IImageService imageService, IDomainService domainService,
			 ILogger<ScaffoldGroupService> logger)
		{
			_context = context;
			_modelMapper = modelMapper;
			_userAuthHelper = userAuthHelper;
			_metadataService = metadataService;
			_scaffoldGroupRepository = scaffoldGroupRepository;
			_descriptorService = descriptorService;
			_imageService = imageService;
			_downloadService = downloadService;
			_tagService = tagService;
			_domainService = domainService;
			_logger = logger;
		}

		public async Task<List<int>> GetAllIds()
		{
			return await _scaffoldGroupRepository.GetAllIds();
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupBaseDto? CreatedScaffoldGroup)> CreateScaffoldGroup(ScaffoldGroupToCreateDto scaffoldGroupToCreate, string? userId)
		{
			var (succeeded, errorMessage, createdScaffoldGroups) = await CreateScaffoldGroups([scaffoldGroupToCreate], userId);

			return (succeeded, errorMessage, createdScaffoldGroups?.FirstOrDefault());
		}

		public async Task<(bool Succeeded, string ErrorMessage, IEnumerable<ScaffoldGroupBaseDto>? CreatedScaffoldGroups)> CreateScaffoldGroups(IEnumerable<ScaffoldGroupToCreateDto> scaffoldGroupsToCreate, string? userId)
		{
			try
			{
				var createdScaffoldGroups = new List<ScaffoldGroupBaseDto>();
				foreach (var dto in scaffoldGroupsToCreate)
				{
					var isAdmin = false;
					if (!string.IsNullOrWhiteSpace(userId))
					{
						isAdmin = await _userAuthHelper.IsInRole(userId, "administrator");
						dto.UploaderId = userId;
					}

					var scaffoldGroup = await _modelMapper.MapToScaffoldGroup(dto);

					if (scaffoldGroup.UploaderId != null && isAdmin == true)
					{
						scaffoldGroup.IsPublic = true;
					}

					if (scaffoldGroup.UploaderId == null)
					{
						var uploader = await _userAuthHelper.GetFirstUserByRoleAsync("administrator");
						if (uploader != null)
						{
							scaffoldGroup.Uploader = uploader;  // Attach the uploader object
							scaffoldGroup.UploaderId = uploader.Id;  // Ensure the ID is set
							scaffoldGroup.IsPublic = true;
						}
					}

					var autogeneratedTags = await _tagService.GetAutogeneratedTagsForScaffold(scaffoldGroup);
					var tagNames = autogeneratedTags.Select(tag => tag.Tag.Name).ToList();

					foreach (var scaffold in scaffoldGroup.Scaffolds)
					{
						scaffold.ScaffoldTags = autogeneratedTags.ToList();
					}

					_scaffoldGroupRepository.Add(scaffoldGroup);
					var scaffoldGroupToReturn = _modelMapper.MapToScaffoldGroupSummaryDto(scaffoldGroup, [], tagNames, userId ?? scaffoldGroup.UploaderId!);
					createdScaffoldGroups.Add(scaffoldGroupToReturn);
				}

				await _context.SaveChangesAsync();
				return (true, "", createdScaffoldGroups);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to create scaffold groups");
				return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, BatchOperationResult? result)> ResetNamesAndComments(List<int> ids)
		{
			if (ids == null || ids.Count == 0)
			{
				return (false, "No scaffold group IDs provided", null);
			}

			var scaffoldGroups = await _scaffoldGroupRepository.GetWithInputDataByIds(ids);
			var result = new BatchOperationResult();

			foreach (var group in scaffoldGroups)
			{
				try
				{
					_metadataService.SetScaffoldGroupNameAndComments(group);

					result.SucceededIds.Add(group.Id);
				}
				catch (Exception ex)
				{
					_logger.LogError(ex, $"Error updating title & comments for scaffold group {group.Id}");
					result.FailedIds.Add(group.Id);
					return (false, $"Error updating title & comments for scaffold group {group.Id}", result);
				}

			}

			try
			{
				await _context.SaveChangesAsync();
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Error saving updated scaffold group names/comments");
				return (false, "Error saving updated scaffold group names/comments", result);
			}

			return (true, "", result);
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupBaseDto? scaffoldGroup)> GetScaffoldGroup(int id, string userId, int? numReplicates)
		{
			try
			{
				// ScaffoldGroup? scaffoldGroup = await _scaffoldGroupRepository.Get(id); 
				var scaffoldGroup  = await _scaffoldGroupRepository.GetSummary(id);

				if (scaffoldGroup == null)
				{
					return (false, "NotFound", null);
				}
				if (scaffoldGroup.IsPublic == false && scaffoldGroup.UploaderId != userId)
				{
					return (false, "Unauthorized", null);
				}

				var (succeeded, errorMessage, completeScaffoldGroups) = 
					await GetCompleteScaffoldGroupsFromSummaries([scaffoldGroup], userId, isDetailed: true, filter: null);

				if (!succeeded || completeScaffoldGroups == null)
				{
					return (false, errorMessage, null);
				}

				return (true, "", completeScaffoldGroups.First());

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group {id}", id);
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupSummaryDto? scaffoldGroup)> GetScaffoldGroupSummaryByScaffoldId(int scaffoldId, string userId)
		{
			try
			{
				// ScaffoldGroup? scaffoldGroup = await _scaffoldGroupRepository.Get(id); 
				var scaffoldGroup  = await _scaffoldGroupRepository.GetSummaryByScaffoldId(scaffoldId);

				if (scaffoldGroup == null)
				{
					return (false, "NotFound", null);
				}
				if (scaffoldGroup.IsPublic == false && scaffoldGroup.UploaderId != userId)
				{
					return (false, "Unauthorized", null);
				}

				return (true, "", scaffoldGroup);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group {scaffoldId}", scaffoldId);
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupSummaryDto? scaffoldGroup)> GetScaffoldGroupSummary(int id, string userId)
		{
			try
			{
				// ScaffoldGroup? scaffoldGroup = await _scaffoldGroupRepository.Get(id); 
				var scaffoldGroup  = await _scaffoldGroupRepository.GetSummary(id);

				if (scaffoldGroup == null)
				{
					return (false, "NotFound", null);
				}
				if (scaffoldGroup.IsPublic == false && scaffoldGroup.UploaderId != userId)
				{
					return (false, "Unauthorized", null);
				}

				return (true, "", scaffoldGroup);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group {id}", id);
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, IEnumerable<ScaffoldGroupBaseDto>? scaffoldGroups)>
			GetFilteredScaffoldGroups(ScaffoldFilter filter, string userId, bool isDetailed = false)
		{
			try
			{
				// Ensure we have a valid user
				if (string.IsNullOrEmpty(userId))
				{
					var user = await _userAuthHelper.GetFirstUserByRoleAsync("administrator");
					userId = user!.Id;
					isDetailed = false;
				}

				if (filter.TagNames?.Count > 0) {
					var tagIdsFromNames = await _tagService.GetAutogeneratedTagIdsFromNames(filter.TagNames);
					filter.TagIds = (filter.TagIds ?? new List<int>()).Union(tagIdsFromNames).ToList();
				}

				// Fetch scaffold groups with necessary fields
				var scaffoldGroups = await _scaffoldGroupRepository.GetFilteredScaffoldGroupSummaries(filter, userId);

				if (scaffoldGroups == null || !scaffoldGroups.Any())
				{
					return (false, "NotFound", null);
				}

				return await GetCompleteScaffoldGroupsFromSummaries(scaffoldGroups, userId, isDetailed, filter);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get filtered scaffold groups");
				return (false, "UnexpectedError", null);
			}
		}

		private async Task<(bool Succeeded, string ErrorMessage, IEnumerable<ScaffoldGroupBaseDto>? scaffoldGroups)> GetCompleteScaffoldGroupsFromSummaries(IEnumerable<ScaffoldGroupSummaryDto> scaffoldGroups, string userId, bool isDetailed, ScaffoldFilter? filter)
		{
			try
			{
				var scaffoldGroupIds = scaffoldGroups.Select(sg => sg.Id).ToList();

				var imagesLookup = isDetailed
						? await _imageService.GetAllImagesForScaffoldGroups(scaffoldGroupIds)
						: await _imageService.GetThumbnailsForScaffoldGroups(scaffoldGroupIds);
				var tagsLookup = await _tagService.GetTagNamesForScaffoldGroups(scaffoldGroupIds, userId);

				Dictionary<int, List<ScaffoldBaseDto>> scaffoldLookup = [];

				if (isDetailed)
				{
					var scaffoldIds = scaffoldGroups
						.SelectMany(sg => sg.ScaffoldIds)
						.ToList();					
					
					var scaffolds = await _descriptorService.GetScaffoldsWithDescriptorsFromScaffoldIds(scaffoldIds, filter);
					scaffoldLookup = scaffolds
						.GroupBy(s => scaffoldGroups.First(sg => sg.ScaffoldIds.Contains(s.Id)).Id)
						.ToDictionary(g => g.Key, g => g.ToList());
				}

				var scaffoldGroupDtos = scaffoldGroups.Select<ScaffoldGroupSummaryDto, ScaffoldGroupBaseDto>(sg =>
				{
					// Assign images and tags once
					sg.Images = imagesLookup.ContainsKey(sg.Id) ? imagesLookup[sg.Id] : [];
					sg.Tags = tagsLookup.ContainsKey(sg.Id) ? tagsLookup[sg.Id] : [];

					// If isDetailed == false, return sg as it is (remains ScaffoldGroupSummaryDto)
					if (!isDetailed) return sg;

					// Create and return ScaffoldGroupDetailedDto
					return new ScaffoldGroupDetailedDto
					{
						Id = sg.Id,
						Name = sg.Name,
						CreatedAt = sg.CreatedAt,
						UploaderId = sg.UploaderId,
						IsPublic = sg.IsPublic,
						IsSimulated = sg.IsSimulated,
						Tags = sg.Tags,
						NumReplicates = sg.NumReplicates,
						Images = sg.Images,
						Inputs = sg.Inputs,
						ScaffoldIds = sg.ScaffoldIds,
						ScaffoldIdsWithDomains = sg.ScaffoldIdsWithDomains,
						Scaffolds = scaffoldLookup.ContainsKey(sg.Id) ? scaffoldLookup[sg.Id] : []
					};
				}).ToList();

				return (true, "", scaffoldGroupDtos);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get filtered scaffold groups");
				return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage)> DeleteScaffoldGroup(int scaffoldGroupId, string userId)
		{
			try
			{
				var scaffoldGroup = await _scaffoldGroupRepository.Get(scaffoldGroupId);
				if (scaffoldGroup == null)
					return (false, "Scaffold group not found.");

				// Authorization check: must be uploader or admin
				var isAdmin = await _userAuthHelper.IsInRole(userId, "administrator");

				if (scaffoldGroup.UploaderId != userId && !isAdmin)
					return (false, "Unauthorized to delete this scaffold group.");

				// 1. Gather all image IDs (group-level + scaffold-level)
				var imageIds = scaffoldGroup.Images.Select(img => img.Id).ToList();

				foreach (var scaffold in scaffoldGroup.Scaffolds)
				{
					imageIds.AddRange(scaffold.Images.Select(img => img.Id));
				}

				if (imageIds.Any())
				{
					var (imgSucceeded, failedImageIds) = await _imageService.DeleteImages(imageIds.Distinct(), userId);
					if (!imgSucceeded)
					{
						return (false, $"Failed to delete some images from Cloudinary: {string.Join(", ", failedImageIds)}");
					}
				}

				// 2. Delete all mesh files from disk
				var domainsWithFiles = scaffoldGroup.Scaffolds
					.SelectMany(s => s.Domains)
					.ToList();

				foreach (var domain in domainsWithFiles)
				{
					var (success, error) = await _domainService.DeleteDomain(domain.Id, userId);
					if (!success)
					{
						return (false, $"Failed to delete domain ID {domain.Id}: {error}");
					}
				}
				// 3. Remove the scaffold group (EF cascade will clean up child entities)
				_scaffoldGroupRepository.Delete(scaffoldGroup);
				await _context.SaveChangesAsync(); // call SaveChanges from your repository

				return (true, "");
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Error deleting scaffold group {ScaffoldGroupId}", scaffoldGroupId);
				return (false, "Unexpected error occurred while deleting the scaffold group.");
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ICollection<ImageToShowDto>? scaffoldGroupImages)> GetScaffoldGroupImages(int scaffoldGroupId)
		{
			try
			{
				var images = await _scaffoldGroupRepository.GetScaffoldGroupImages(scaffoldGroupId);
				var imagesToReturn = images.Select(_modelMapper.MapImageToDto).ToList();
				return (true, "", imagesToReturn);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group images");
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupSummaryDto? updatedScaffoldGroup)> UpdateScaffoldGroupImage(string userId, int scaffoldGroupId, ImageToUpdateDto image)
		{
			try
			{
				var scaffoldGroup = await _scaffoldGroupRepository.Get(scaffoldGroupId);

				if (scaffoldGroup == null) return (false, "ScaffoldGroup not found", null);

				if (scaffoldGroup.UploaderId != userId) return (false, "Unauthorized", null);

				var updatedImage = await _imageService.UpdateImage(image, scaffoldGroup);

				if (updatedImage == null) return (false, "Image not found", null);

				var updatedScaffoldGroup = await _scaffoldGroupRepository.Get(scaffoldGroupId);
				var images = await _scaffoldGroupRepository.GetScaffoldGroupImages(scaffoldGroupId);
				var scaffoldGroupToReturn = _modelMapper.MapToScaffoldGroupSummaryDto(updatedScaffoldGroup!, images, [], userId);

				return (true, "", scaffoldGroupToReturn);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to update scaffold group image");
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<List<ScaffoldMissingThumbnailInfoDto>> GetScaffoldsMissingThumbnailsByCategory(ImageCategory imageCategory = ImageCategory.Particles)
		{
			try
			{
				var scaffolds = await _scaffoldGroupRepository.GetScaffoldsMissingThumbnailsByCategory(imageCategory);
				return scaffolds;
			}
			catch (Exception ex)
			{
				
				_logger.LogError(ex, "Error getting thumbnails");
				return [];
			}
		}


	}
}


