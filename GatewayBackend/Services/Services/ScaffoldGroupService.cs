
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data;
using Data.Models;
using Repositories.IRepositories;
using Infrastructure.DTOs;
using Infrastructure.IHelpers;
using Services.IServices;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using CloudinaryDotNet;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Services.Services
{	public class ScaffoldGroupService : IScaffoldGroupService
	{
		private readonly DataContext _context;
		private readonly IModelMapper _modelMapper;
		private readonly IUserAuthHelper _userAuthHelper;
		private readonly IScaffoldGroupMetadataService _metadataService;
		private readonly IScaffoldGroupRepository _scaffoldGroupRepository;
		private readonly IDescriptorService _descriptorService;
		private readonly IDownloadService _downloadService;
		private readonly IDomainService _domainService;
		private readonly ITagService _tagService;
		private readonly IImageService _imageService;
		private readonly ILogger<ScaffoldGroupService> _logger;

		public ScaffoldGroupService(DataContext context, IModelMapper modelMapper, 
			IScaffoldGroupMetadataService metadataService, IScaffoldGroupRepository scaffoldGroupRepository, 
			IDescriptorService descriptorService, IDownloadService downloadService, ITagService tagService, 
			IUserAuthHelper userAuthHelper, IImageService imageService, IDomainService domainService,
			 ILogger<ScaffoldGroupService> logger)
		{
			_context = context;
			_modelMapper = modelMapper;
			_userAuthHelper = userAuthHelper;
			_metadataService = metadataService;
			_scaffoldGroupRepository = scaffoldGroupRepository;
			_descriptorService = descriptorService;
			_imageService = imageService;
			_downloadService = downloadService;
			_tagService = tagService;
			_domainService = domainService;
			_logger = logger;
		}

		public async Task<List<int>> GetAllIds()
		{
			return await _scaffoldGroupRepository.GetAllIds();
		}

		public async Task<int> GetRandomScaffoldGroupId()
		{
			return await _scaffoldGroupRepository.GetRandomScaffoldGroupId();
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupBaseDto? CreatedScaffoldGroup)> CreateScaffoldGroup(ScaffoldGroupToCreateDto scaffoldGroupToCreate, string? userId)
		{
			var (succeeded, errorMessage, createdScaffoldGroups) = await CreateScaffoldGroups([scaffoldGroupToCreate], userId);

			return (succeeded, errorMessage, createdScaffoldGroups?.FirstOrDefault());
		}

		public async Task<(bool Succeeded, string ErrorMessage, IEnumerable<ScaffoldGroupBaseDto>? CreatedScaffoldGroups)> CreateScaffoldGroups(IEnumerable<ScaffoldGroupToCreateDto> scaffoldGroupsToCreate, string? userId)
		{
			try
			{
				var createdScaffoldGroups = new List<ScaffoldGroupBaseDto>();
				foreach (var dto in scaffoldGroupsToCreate)
				{
					var isAdmin = false;
					if (!string.IsNullOrWhiteSpace(userId))
					{
						isAdmin = await _userAuthHelper.IsInRole(userId, "administrator");
						dto.UploaderId = userId;
					}

					var scaffoldGroup = await _modelMapper.MapToScaffoldGroup(dto);

					if (scaffoldGroup.UploaderId != null && isAdmin == true)
					{
						scaffoldGroup.IsPublic = true;
					}

					if (scaffoldGroup.UploaderId == null)
					{
						var uploader = await _userAuthHelper.GetFirstUserByRoleAsync("administrator");
						if (uploader != null)
						{
							scaffoldGroup.Uploader = uploader;  // Attach the uploader object
							scaffoldGroup.UploaderId = uploader.Id;  // Ensure the ID is set
							scaffoldGroup.IsPublic = true;
						}
					}

					var autogeneratedTags = await _tagService.GetAutogeneratedTagsForScaffold(scaffoldGroup);
					var tagNames = autogeneratedTags.Select(tag => tag.Tag.Name).ToList();

					foreach (var scaffold in scaffoldGroup.Scaffolds)
					{
						scaffold.ScaffoldTags = autogeneratedTags.ToList();
					}

					_scaffoldGroupRepository.Add(scaffoldGroup);
					var scaffoldGroupToReturn = _modelMapper.MapToScaffoldGroupSummaryDto(scaffoldGroup, [], tagNames, userId ?? scaffoldGroup.UploaderId!);
					createdScaffoldGroups.Add(scaffoldGroupToReturn);
				}

				await _context.SaveChangesAsync();
				return (true, "", createdScaffoldGroups);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to create scaffold groups");
				return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, IEnumerable<ScaffoldGroupBaseDto>? CreatedScaffoldGroups)>
			CreateScaffoldGroupsFromJsonStream(
				Stream jsonStream,
				string userId,
				int batchSize = 50,
				CancellationToken ct = default)
		{
			try
			{
				var opts = new JsonSerializerOptions
				{
					PropertyNameCaseInsensitive = true,
					DefaultBufferSize = 1 << 20, // 1MB buffer; tune as needed
					NumberHandling = JsonNumberHandling.AllowReadingFromString
				};

				var createdAll = new List<ScaffoldGroupBaseDto>(capacity: batchSize * 2);
				var buffer = new List<ScaffoldGroupToCreateDto>(capacity: batchSize);

				// Expecting a top-level JSON array of ScaffoldGroupToCreateDto
				await foreach (var dto in JsonSerializer.DeserializeAsyncEnumerable<ScaffoldGroupToCreateDto>(jsonStream, opts, ct))
				{
					ct.ThrowIfCancellationRequested();
					if (dto is null) continue; // can occur between tokens/whitespace

					buffer.Add(dto);

					if (buffer.Count >= batchSize)
					{
						var (ok, err, createdBatch) = await CreateScaffoldGroups(buffer, userId);
						if (!ok)
							return (false, err, null);

						if (createdBatch != null)
							createdAll.AddRange(createdBatch);

						buffer.Clear();
					}
				}

				// flush remaining
				if (buffer.Count > 0)
				{
					var (ok, err, createdBatch) = await CreateScaffoldGroups(buffer, userId);
					if (!ok)
						return (false, err, null);

					if (createdBatch != null)
						createdAll.AddRange(createdBatch);
				}

				return (true, string.Empty, createdAll);
			}
			catch (JsonException jex)
			{
				_logger.LogError(jex, "Invalid JSON in streamed scaffold group upload");
				return (false, "InvalidJson", null);
			}
			catch (OperationCanceledException)
			{
				return (false, "Canceled", null);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to create scaffold groups from streamed JSON");
				return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, BatchOperationResult? result)> ResetNamesAndComments(List<int> ids)
		{
			if (ids == null || ids.Count == 0)
			{
				return (false, "No scaffold group IDs provided", null);
			}

			var scaffoldGroups = await _scaffoldGroupRepository.GetWithInputDataByIds(ids);
			var result = new BatchOperationResult();

			foreach (var group in scaffoldGroups)
			{
				try
				{
					_metadataService.SetScaffoldGroupNameAndComments(group);

					result.SucceededIds.Add(group.Id);
				}
				catch (Exception ex)
				{
					_logger.LogError(ex, $"Error updating title & comments for scaffold group {group.Id}");
					result.FailedIds.Add(group.Id);
					return (false, $"Error updating title & comments for scaffold group {group.Id}", result);
				}

			}

			try
			{
				await _context.SaveChangesAsync();
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Error saving updated scaffold group names/comments");
				return (false, "Error saving updated scaffold group names/comments", result);
			}

			return (true, "", result);
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupBaseDto? scaffoldGroup)> GetScaffoldGroup(int id, string userId, int? numReplicates)
		{
			try
			{
				// ScaffoldGroup? scaffoldGroup = await _scaffoldGroupRepository.Get(id); 
				var scaffoldGroup  = await _scaffoldGroupRepository.GetSummary(id);

				if (scaffoldGroup == null)
				{
					return (false, "NotFound", null);
				}
				if (scaffoldGroup.IsPublic == false && scaffoldGroup.UploaderId != userId)
				{
					return (false, "Unauthorized", null);
				}

				var (succeeded, errorMessage, completeScaffoldGroups) = 
					await GetCompleteScaffoldGroupsFromSummaries([scaffoldGroup], userId, isDetailed: true, filter: null);

				if (!succeeded || completeScaffoldGroups == null)
				{
					return (false, errorMessage, null);
				}

				return (true, "", completeScaffoldGroups.First());

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group {id}", id);
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupSummaryDto? scaffoldGroup)> GetScaffoldGroupSummaryByScaffoldId(int scaffoldId, string userId)
		{
			try
			{
				// ScaffoldGroup? scaffoldGroup = await _scaffoldGroupRepository.Get(id); 
				var scaffoldGroup  = await _scaffoldGroupRepository.GetSummaryByScaffoldId(scaffoldId);

				if (scaffoldGroup == null)
				{
					return (false, "NotFound", null);
				}
				if (scaffoldGroup.IsPublic == false && scaffoldGroup.UploaderId != userId)
				{
					return (false, "Unauthorized", null);
				}

				return (true, "", scaffoldGroup);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group {scaffoldId}", scaffoldId);
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupSummaryDto? scaffoldGroup)> GetScaffoldGroupSummary(int id, string userId)
		{
			try
			{
				// ScaffoldGroup? scaffoldGroup = await _scaffoldGroupRepository.Get(id); 
				var scaffoldGroup  = await _scaffoldGroupRepository.GetSummary(id);

				if (scaffoldGroup == null)
				{
					return (false, "NotFound", null);
				}
				if (scaffoldGroup.IsPublic == false && scaffoldGroup.UploaderId != userId)
				{
					return (false, "Unauthorized", null);
				}

				return (true, "", scaffoldGroup);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group {id}", id);
        		return (false, "UnexpectedError", null);
			}
		}
		
		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupDataDto? Result)> GetDataForVisualization(int scaffoldGroupId, string? userId,  List<int> descriptorTypeIds)
		{
			try
			{
				var summary = await _scaffoldGroupRepository.GetSummary(scaffoldGroupId);
				if (summary == null) return (false, "Scaffold group not found", null);

				var (poreInfoSucceeded, poreInfoErrorMesssage, poreData) = await _descriptorService.GetPoreDescriptorInfoScaffoldGroup(scaffoldGroupId, descriptorTypeIds);
				if (!poreInfoSucceeded || poreData == null) return (false, poreInfoErrorMesssage, null);

				if (string.IsNullOrEmpty(userId))
				{
					var user = await _userAuthHelper.GetFirstUserByRoleAsync("administrator");
					userId = user!.Id;
				}

				var (succeededScaffoldGroups, errorMessageScaffoldGroup, completeScaffoldGroups) = 
					await GetCompleteScaffoldGroupsFromSummaries([summary], userId, isDetailed: false, filter: null);

				if (!succeededScaffoldGroups || completeScaffoldGroups == null) return (false, errorMessageScaffoldGroup, null);

				var completeScaffoldGroup = completeScaffoldGroups.FirstOrDefault();

				var dto = new ScaffoldGroupDataDto
				{
					ScaffoldGroupId = scaffoldGroupId,
					ScaffoldGroup = completeScaffoldGroup!,
					PoreDescriptors = poreData.Scaffolds
				};

				return (true, "", dto);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to load scaffold group data");
				return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, IEnumerable<ScaffoldGroupBaseDto>? scaffoldGroups)>
			GetFilteredScaffoldGroups(ScaffoldFilter filter, string userId, bool isDetailed = false)
		{
			try
			{
				// Ensure we have a valid user
				if (string.IsNullOrEmpty(userId))
				{
					var user = await _userAuthHelper.GetFirstUserByRoleAsync("administrator");
					userId = user!.Id;
					isDetailed = false;
				}

				if (filter.TagNames?.Count > 0)
				{
					var tagIdsFromNames = await _tagService.GetAutogeneratedTagIdsFromNames(filter.TagNames);
					filter.TagIds = (filter.TagIds ?? new List<int>()).Union(tagIdsFromNames).ToList();
				}

				// Fetch scaffold groups with necessary fields
				var scaffoldGroups = await _scaffoldGroupRepository.GetFilteredScaffoldGroupSummaries(filter, userId);

				// if (scaffoldGroups == null || !scaffoldGroups.Any())
				// {
				// 	return (false, "NotFound", null);
				// }

				return await GetCompleteScaffoldGroupsFromSummaries(scaffoldGroups ?? [], userId, isDetailed, filter);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get filtered scaffold groups");
				return (false, "UnexpectedError", null);
			}
		}

		private async Task<(bool Succeeded, string ErrorMessage, IEnumerable<ScaffoldGroupBaseDto>? scaffoldGroups)> GetCompleteScaffoldGroupsFromSummaries(IEnumerable<ScaffoldGroupSummaryDto> scaffoldGroups, string userId, bool isDetailed, ScaffoldFilter? filter)
		{
			try
			{
				var scaffoldGroupIds = scaffoldGroups.Select(sg => sg.Id).ToList();

				var imagesLookup = isDetailed
						? await _imageService.GetAllImagesForScaffoldGroups(scaffoldGroupIds)
						: await _imageService.GetThumbnailsForScaffoldGroups(scaffoldGroupIds);
				var tagsLookup = await _tagService.GetTagNamesForScaffoldGroups(scaffoldGroupIds, userId);

				Dictionary<int, List<ScaffoldBaseDto>> scaffoldLookup = [];

				if (isDetailed)
				{
					var scaffoldIds = scaffoldGroups
						.SelectMany(sg => sg.ScaffoldIds)
						.ToList();					
					
					var scaffolds = await _descriptorService.GetScaffoldsWithDescriptorsFromScaffoldIds(scaffoldIds, filter);
					scaffoldLookup = scaffolds
						.GroupBy(s => scaffoldGroups.First(sg => sg.ScaffoldIds.Contains(s.Id)).Id)
						.ToDictionary(g => g.Key, g => g.ToList());
				}

				var scaffoldGroupDtos = scaffoldGroups.Select<ScaffoldGroupSummaryDto, ScaffoldGroupBaseDto>(sg =>
				{
					// Assign images and tags once
					sg.Images = imagesLookup.ContainsKey(sg.Id) ? imagesLookup[sg.Id] : [];
					sg.Tags = tagsLookup.ContainsKey(sg.Id) ? tagsLookup[sg.Id] : [];

					// If isDetailed == false, return sg as it is (remains ScaffoldGroupSummaryDto)
					if (!isDetailed) return sg;

					// Create and return ScaffoldGroupDetailedDto
					return new ScaffoldGroupDetailedDto
					{
						Id = sg.Id,
						Name = sg.Name,
						CreatedAt = sg.CreatedAt,
						UploaderId = sg.UploaderId,
						IsPublic = sg.IsPublic,
						IsSimulated = sg.IsSimulated,
						Tags = sg.Tags,
						NumReplicates = sg.NumReplicates,
						Images = sg.Images,
						Inputs = sg.Inputs,
						ScaffoldIds = sg.ScaffoldIds,
						ScaffoldIdsWithDomains = sg.ScaffoldIdsWithDomains,
						Scaffolds = scaffoldLookup.ContainsKey(sg.Id) ? scaffoldLookup[sg.Id] : []
					};
				}).ToList();

				return (true, "", scaffoldGroupDtos);

			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get filtered scaffold groups");
				return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage)> DeleteScaffoldGroup(int scaffoldGroupId, string userId)
		{
			try
			{
				var scaffoldGroup = await _scaffoldGroupRepository.Get(scaffoldGroupId);
				if (scaffoldGroup == null)
					return (false, "Scaffold group not found.");

				// Authorization check: must be uploader or admin
				var isAdmin = await _userAuthHelper.IsInRole(userId, "administrator");

				if (scaffoldGroup.UploaderId != userId && !isAdmin)
					return (false, "Unauthorized to delete this scaffold group.");

				// 1. Gather all image IDs (group-level + scaffold-level)
				var imageIds = scaffoldGroup.Images.Select(img => img.Id).ToList();

				foreach (var scaffold in scaffoldGroup.Scaffolds)
				{
					imageIds.AddRange(scaffold.Images.Select(img => img.Id));
				}

				if (imageIds.Any())
				{
					var (imgSucceeded, failedImageIds) = await _imageService.DeleteImages(imageIds.Distinct(), userId);
					if (!imgSucceeded)
					{
						return (false, $"Failed to delete some images from Cloudinary: {string.Join(", ", failedImageIds)}");
					}
				}

				// 2. Delete all mesh files from disk
				var domainsWithFiles = scaffoldGroup.Scaffolds
					.SelectMany(s => s.Domains)
					.ToList();

				foreach (var domain in domainsWithFiles)
				{
					var (success, error) = await _domainService.DeleteDomain(domain.Id, userId);
					if (!success)
					{
						return (false, $"Failed to delete domain ID {domain.Id}: {error}");
					}
				}
				// 3. Remove the scaffold group (EF cascade will clean up child entities)
				_scaffoldGroupRepository.Delete(scaffoldGroup);
				await _context.SaveChangesAsync(); // call SaveChanges from your repository

				return (true, "");
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Error deleting scaffold group {ScaffoldGroupId}", scaffoldGroupId);
				return (false, "Unexpected error occurred while deleting the scaffold group.");
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ICollection<ImageToShowDto>? scaffoldGroupImages)> GetScaffoldGroupImages(int scaffoldGroupId)
		{
			try
			{
				var images = await _scaffoldGroupRepository.GetScaffoldGroupImages(scaffoldGroupId);
				var imagesToReturn = images.Select(_modelMapper.MapImageToDto).ToList();
				return (true, "", imagesToReturn);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get scaffold group images");
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, ScaffoldGroupSummaryDto? updatedScaffoldGroup)> UpdateScaffoldGroupImage(string userId, int scaffoldGroupId, ImageToUpdateDto image)
		{
			try
			{
				var scaffoldGroup = await _scaffoldGroupRepository.Get(scaffoldGroupId);

				if (scaffoldGroup == null) return (false, "ScaffoldGroup not found", null);

				if (scaffoldGroup.UploaderId != userId) return (false, "Unauthorized", null);

				var updatedImage = await _imageService.UpdateImage(image, scaffoldGroup);

				if (updatedImage == null) return (false, "Image not found", null);

				var updatedScaffoldGroup = await _scaffoldGroupRepository.Get(scaffoldGroupId);
				var images = await _scaffoldGroupRepository.GetScaffoldGroupImages(scaffoldGroupId);
				var scaffoldGroupToReturn = _modelMapper.MapToScaffoldGroupSummaryDto(updatedScaffoldGroup!, images, [], userId);

				return (true, "", scaffoldGroupToReturn);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to update scaffold group image");
        		return (false, "UnexpectedError", null);
			}
		}

		public async Task<List<ScaffoldMissingThumbnailInfoDto>> GetScaffoldsMissingThumbnailsByCategory(ImageCategory imageCategory = ImageCategory.Particles)
		{
			try
			{
				var scaffolds = await _scaffoldGroupRepository.GetScaffoldsMissingThumbnailsByCategory(imageCategory);
				return scaffolds;
			}
			catch (Exception ex)
			{

				_logger.LogError(ex, "Error getting thumbnails");
				return [];
			}
		}

		public async Task<(bool Succeeded, string ErrorMessage, List<ScaffoldGroupMatch>? scaffoldGroupMatches)> FindPotentialMatches(
			InputGroupForMatchRequest request,
			string userId,
			int topN = 5)
		{
			try
			{
				// For experimental scaffolds, return empty - always create new
				if (!request.IsSimulated)
					return (true, "", new List<ScaffoldGroupMatch>());

				// Build filter from request
				var filter = new ScaffoldFilter
				{
					UserId = userId,
					ParticleSizes = request.Particles
						.Select(p => (int)p.MeanSize)
						.Distinct()
						.ToList()
				};

				// Get potential candidates
				var candidates = await _scaffoldGroupRepository.GetFilteredScaffoldGroupSummaries(filter, userId);

				if (candidates == null) return (true, "No matches found", new List<ScaffoldGroupMatch>());

				// Score each candidate
				var matches = candidates
					.Select(sg => new ScaffoldGroupMatch
					{
						ScaffoldGroupId = sg.Id,
						Name = sg.Name ?? "N/A",
						MatchScore = CalculateMatchScore(request, sg, out var differences),
						Differences = differences,
						Details = sg
					})
					.Where(m => m.MatchScore >= 70) // Threshold for "good enough"
					.OrderByDescending(m => m.MatchScore)
					.Take(topN)
					.ToList();

				return (true, "", matches);
			}
			catch (Exception ex)
			{
				_logger.LogError(ex, "Failed to get candidate matches");
        		return (false, "UnexpectedError", null);
			}
			
		}

		private double CalculateMatchScore(
			InputGroupForMatchRequest request,
			ScaffoldGroupSummaryDto candidate,
			out Dictionary<string, string> differences)
		{
			differences = new Dictionary<string, string>();
			double score = 100.0;

			// Container shape (critical - major penalty)
			if (candidate?.Inputs?.ContainerShape != request.ContainerShape)
			{
				score -= 30;
				differences["ContainerShape"] = $"{candidate?.Inputs?.ContainerShape ?? "None"} vs {request.ContainerShape ?? "None"}";
			}

			// Container size (allow small tolerance)
			if (candidate?.Inputs?.ContainerSize.HasValue == true && request.ContainerSize.HasValue)
			{
				var sizeDiff = Math.Abs(candidate.Inputs.ContainerSize.Value - request.ContainerSize.Value);
				if (sizeDiff > 0.01)
				{
					score -= Math.Min(20, sizeDiff * 10);
					differences["ContainerSize"] = $"{candidate.Inputs.ContainerSize} vs {request.ContainerSize}";
				}
			}
			else if (candidate?.Inputs?.ContainerSize.HasValue != request.ContainerSize.HasValue)
			{
				// One has a value, the other doesn't
				score -= 15;
				differences["ContainerSize"] = $"{candidate?.Inputs?.ContainerSize?.ToString() ?? "Not specified"} vs {request.ContainerSize?.ToString() ?? "Not specified"}";
			}

			// Packing configuration
			var candidatePackingConfig = candidate?.Inputs?.PackingConfiguration?.ToString();
			if (candidatePackingConfig != request.PackingConfiguration)
			{
				score -= 20;
				differences["PackingConfiguration"] = $"{candidatePackingConfig ?? "None"} vs {request.PackingConfiguration ?? "None"}";
			}

			// Compare particles (this gets more complex)
			score -= CompareParticleProperties(request.Particles, candidate?.Inputs?.Particles ?? new List<ParticlePropertyBaseDto>(), differences);

			return Math.Max(0, score);
		}
		
		private double CompareParticleProperties(
			IEnumerable<ParticlePropertyGroupToCreateDto> requestParticles,
			IEnumerable<ParticlePropertyBaseDto> candidateParticles,
			Dictionary<string, string> differences)
		{
			double penalty = 0.0;

			var candidateParticlesList = candidateParticles.ToList();
			var requestedParticlesList = requestParticles.ToList();

			// Check if particle counts match
			if (requestedParticlesList.Count != candidateParticlesList.Count)
			{
				penalty += 15;
				differences["ParticleCount"] = $"{candidateParticlesList.Count} particle types vs {requestedParticlesList.Count} particle types";
				// If counts differ significantly, return early with heavy penalty
				if (Math.Abs(requestedParticlesList.Count - candidateParticlesList.Count) > 1)
					return penalty + 20;
			}

			// Sort both lists by MeanSize for consistent comparison
			var sortedRequest = requestParticles.OrderBy(p => p.MeanSize).ToList();
			var sortedCandidate = candidateParticlesList.OrderBy(p => p.MeanSize).ToList();

			// Compare each particle type
			int comparisonCount = Math.Min(sortedRequest.Count, sortedCandidate.Count);
			for (int i = 0; i < comparisonCount; i++)
			{
				var reqParticle = sortedRequest[i];
				var candParticle = sortedCandidate[i];

				// Shape comparison (critical)
				if (reqParticle.Shape != candParticle.Shape)
				{
					penalty += 10;
					differences[$"Particle{i + 1}_Shape"] = $"{candParticle.Shape} vs {reqParticle.Shape}";
				}

				// Stiffness comparison
				if (reqParticle.Stiffness != candParticle.Stiffness)
				{
					penalty += 5;
					differences[$"Particle{i + 1}_Stiffness"] = $"{candParticle.Stiffness} vs {reqParticle.Stiffness}";
				}

				// Dispersity comparison
				if (reqParticle.Dispersity != candParticle.Dispersity)
				{
					penalty += 5;
					differences[$"Particle{i + 1}_Dispersity"] = $"{candParticle.Dispersity} vs {reqParticle.Dispersity}";
				}

				// Mean size comparison (allow small tolerance)
				var sizeDiff = Math.Abs(reqParticle.MeanSize - candParticle.MeanSize);
				if (sizeDiff > 1.0) // More than 1 unit difference
				{
					penalty += Math.Min(8, sizeDiff * 0.5);
					differences[$"Particle{i + 1}_MeanSize"] = $"{candParticle.MeanSize:F2} vs {reqParticle.MeanSize:F2}";
				}

				// Standard deviation comparison (if both specified)
				if (reqParticle.StandardDeviationSize > 0 && candParticle.StandardDeviationSize.HasValue)
				{
					var stdDevDiff = Math.Abs(reqParticle.StandardDeviationSize - candParticle.StandardDeviationSize.Value);
					if (stdDevDiff > 0.5)
					{
						penalty += Math.Min(5, stdDevDiff);
						differences[$"Particle{i + 1}_StdDev"] = $"{candParticle.StandardDeviationSize:F2} vs {reqParticle.StandardDeviationSize:F2}";
					}
				}

				if (reqParticle.Proportion > 0 && candParticle.Proportion.HasValue)
				{
					// Proportion comparison
					var propDiff = Math.Abs(reqParticle.Proportion - candParticle.Proportion.Value);
					if (propDiff > 0.05) // More than 5% difference
					{
						penalty += Math.Min(5, propDiff * 20);
						differences[$"Particle{i + 1}_Proportion"] = $"{candParticle.Proportion:P0} vs {reqParticle.Proportion:P0}";
					}
				}

				
			}

			return penalty;
		}


	}
}


