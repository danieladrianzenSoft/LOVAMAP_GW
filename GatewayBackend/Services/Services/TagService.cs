
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data;
using Data.Models;
using Infrastructure.DTOs;
using Repositories.IRepositories;
using Services.IServices;

namespace Services.Services
{	public class TagService : ITagService
	{
		private readonly DataContext _context;
		private readonly ITagRepository _tagRepository;
		private readonly IModelMapper _modelMapper;

		public TagService(DataContext context, IModelMapper modelMapper, ITagRepository tagRepository)
		{
			_context = context;
			_modelMapper = modelMapper;
			_tagRepository = tagRepository;
		}

		public async Task CreateTags(IEnumerable<TagToCreateDto> tagsToCreate)
		{
			try
			{
				var tags = tagsToCreate.Select(dto => _modelMapper.MapToTag(dto)).ToList();

				foreach (var tag in tags)
				{
					if (tag == null) continue;
					_tagRepository.Add(tag);
				}
				
				await _context.SaveChangesAsync();
			}
			catch (Exception ex)
			{
				throw new ApplicationException("Error saving tags", ex);
			}
		}

		public async Task<ICollection<TagForFilterDto>> GetAutogeneratedTags()
		{

			var tags = await _tagRepository.GetAutoGeneratedTags();
			var tagsToReturn = new List<TagForFilterDto>();

			foreach (var tag in tags)
			{
				tagsToReturn.Add(_modelMapper.MapTagToDto(tag));
			}
			return tagsToReturn;
		}

		public async Task<ICollection<ScaffoldTag>> GetAutogeneratedTagsForScaffold(ScaffoldGroup scaffoldGroup)
		{
			var tagsToCreate = new List<ScaffoldTagToCreateDto>();
			var dispersities = new List<string>();
			var sizeDistributionTypes = new List<string>();

			foreach (var particlePropertyGroup in scaffoldGroup.InputGroup!.ParticlePropertyGroups)
			{
				// Always add a tag related to the shape and stiffness declared
				AddTagIfNotEmpty(tagsToCreate, particlePropertyGroup.Shape);
				if (!string.IsNullOrWhiteSpace(particlePropertyGroup.Stiffness))
					AddTagIfNotEmpty(tagsToCreate, particlePropertyGroup.Stiffness);

				dispersities.Add(particlePropertyGroup.Dispersity);
				if (!string.IsNullOrWhiteSpace(particlePropertyGroup.SizeDistributionType))
					sizeDistributionTypes.Add(particlePropertyGroup.SizeDistributionType);
			}

			int groupCount = scaffoldGroup.InputGroup.ParticlePropertyGroups.Count;

			// Process tags based on dispersity and size distribution type
			if (groupCount > 1)
			{
				if (dispersities.All(d => d == "monodisperse") && groupCount == 2)
				{
					AddTagIfNotEmpty(tagsToCreate, "bidisperse");
					AddTagIfNotEmpty(tagsToCreate, "bimodal");
				}
				else if (dispersities.Any(d => d == "polydisperse"))
				{
					AddTagIfNotEmpty(tagsToCreate, "polydisperse");
					if (groupCount == 2)
						AddTagIfNotEmpty(tagsToCreate, "bimodal");
				}
				else if (groupCount > 2)
				{
					AddTagIfNotEmpty(tagsToCreate, "polydisperse");
				}
			}
			else if (groupCount == 1)
			{
				var particlePropertyGroup = scaffoldGroup.InputGroup.ParticlePropertyGroups.First();
				AddTagIfNotEmpty(tagsToCreate, particlePropertyGroup.Dispersity);
				if (!string.IsNullOrWhiteSpace(particlePropertyGroup.SizeDistributionType))
					AddTagIfNotEmpty(tagsToCreate, particlePropertyGroup.SizeDistributionType);
			}

			var distinctTagsToCreate = tagsToCreate.Distinct(new ScaffoldTagToCreateDtoComparer()).ToList();
			var tags = new List<ScaffoldTag>();

			// Process each tag creation sequentially
			foreach (var dto in distinctTagsToCreate)
			{
				var tag = await _modelMapper.MapToScaffoldTag(dto);
				if (tag != null)
					tags.Add(tag);
			}

			return tags;
		}


		private static void AddTagIfNotEmpty(ICollection<ScaffoldTagToCreateDto> collection, string tag)
		{
			if (!string.IsNullOrEmpty(tag))
			{
				ScaffoldTagToCreateDto tagToCreate = new()
                {
					Name = tag,
				};
				collection.Add(tagToCreate);
			}
		}

		private class ScaffoldTagToCreateDtoComparer : IEqualityComparer<ScaffoldTagToCreateDto>
		{
			public bool Equals(ScaffoldTagToCreateDto? x, ScaffoldTagToCreateDto? y)
			{
				// Check if both objects are null, or they are the same object
				if (ReferenceEquals(x, y)) return true;
				
				// If one is null, but not both, return false
				if (x == null || y == null) return false;
				
				// Compare the Name properties if neither is null
				return x.Name == y.Name;
			}

			public int GetHashCode(ScaffoldTagToCreateDto obj)
			{
				return obj.Name?.GetHashCode() ?? 0;
			}
		}
	}
}


